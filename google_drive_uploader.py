# import os
# import logging
# import asyncio
# from pathlib import Path
# from typing import Optional, Dict, Any
# from google.oauth2.service_account import Credentials
# from googleapiclient.discovery import build
# from googleapiclient.http import MediaFileUpload
# from googleapiclient.errors import HttpError
# from concurrent.futures import ThreadPoolExecutor

# logger = logging.getLogger(__name__)

# class GoogleDriveUploader:
#     """Async Google Drive uploader for video files"""
    
#     def __init__(self, service_account_path: str, folder_id: Optional[str] = None):
#         """
#         Initialize Google Drive uploader
        
#         Args:
#             service_account_path (str): Path to Google Service Account JSON file
#             folder_id (str, optional): Google Drive folder ID to upload to
#         """
#         self.service_account_path = service_account_path
#         self.folder_id = folder_id
#         self.service = None
#         self.executor = ThreadPoolExecutor(max_workers=2)
        
#         # Initialize the service
#         self._initialize_service()
    
#     def _initialize_service(self):
#         """Initialize Google Drive API service"""
#         try:
#             if not os.path.exists(self.service_account_path):
#                 raise FileNotFoundError(f"Service account file not found: {self.service_account_path}")
            
#             # Set up credentials
#             scopes = ['https://www.googleapis.com/auth/drive']
#             credentials = Credentials.from_service_account_file(
#                 self.service_account_path, 
#                 scopes=scopes
#             )
            
#             # Build the service
#             self.service = build('drive', 'v3', credentials=credentials)
#             logger.info("Google Drive service initialized successfully")
            
#         except Exception as e:
#             logger.error(f"Failed to initialize Google Drive service: {e}")
#             raise
    
#     async def upload_video_async(self, video_path: str, video_name: Optional[str] = None) -> Dict[str, Any]:
#         """
#         Upload video to Google Drive asynchronously
        
#         Args:
#             video_path (str): Path to the video file
#             video_name (str, optional): Name for the uploaded file
            
#         Returns:
#             dict: Upload result with file_id, web_view_link, and download_link
#         """
#         if not os.path.exists(video_path):
#             raise FileNotFoundError(f"Video file not found: {video_path}")
        
#         if not video_name:
#             video_name = Path(video_path).name
        
#         logger.info(f"Starting upload of {video_path} to Google Drive as {video_name}")
        
#         # Prepare file metadata
#         file_metadata = {
#             'name': video_name,
#             'description': f'Optimized video generated by async video processor'
#         }
        
#         # Add to specific folder if provided
#         if self.folder_id:
#             file_metadata['parents'] = [self.folder_id]
        
#         # Run upload in thread pool to avoid blocking
#         loop = asyncio.get_event_loop()
        
#         def upload_sync():
#             try:
#                 # Create media upload object
#                 media = MediaFileUpload(
#                     video_path,
#                     mimetype='video/mp4',
#                     resumable=True,
#                     chunksize=10 * 1024 * 1024  # 10MB chunks for large files
#                 )
                
#                 # Upload the file
#                 request = self.service.files().create(
#                     body=file_metadata,
#                     media_body=media,
#                     fields='id,name,webViewLink,size,createdTime'
#                 )
                
#                 file = request.execute()
                
#                 # Make the file publicly viewable (optional)
#                 self.service.permissions().create(
#                     fileId=file['id'],
#                     body={'role': 'reader', 'type': 'anyone'}
#                 ).execute()
                
#                 # Get direct download link
#                 download_link = f"https://drive.google.com/uc?export=download&id={file['id']}"
                
#                 return {
#                     'success': True,
#                     'file_id': file['id'],
#                     'file_name': file['name'],
#                     'web_view_link': file['webViewLink'],
#                     'download_link': download_link,
#                     'size': file.get('size', 0),
#                     'created_time': file.get('createdTime'),
#                     'folder_id': self.folder_id
#                 }
                
#             except HttpError as e:
#                 logger.error(f"Google Drive HTTP error during upload: {e}")
#                 return {
#                     'success': False,
#                     'error': f"HTTP error: {e.resp.status} - {e.content.decode()}"
#                 }
#             except Exception as e:
#                 logger.error(f"Error during Google Drive upload: {e}")
#                 return {
#                     'success': False,
#                     'error': str(e)
#                 }
        
#         try:
#             result = await loop.run_in_executor(self.executor, upload_sync)
            
#             if result['success']:
#                 logger.info(f"Successfully uploaded {video_name} to Google Drive")
#                 logger.info(f"File ID: {result['file_id']}")
#                 logger.info(f"View Link: {result['web_view_link']}")
#             else:
#                 logger.error(f"Failed to upload {video_name}: {result['error']}")
            
#             return result
            
#         except Exception as e:
#             logger.error(f"Async upload error: {e}")
#             return {
#                 'success': False,
#                 'error': str(e)
#             }
    
#     async def delete_file_async(self, file_id: str) -> bool:
#         """
#         Delete a file from Google Drive
        
#         Args:
#             file_id (str): Google Drive file ID
            
#         Returns:
#             bool: True if successful, False otherwise
#         """
#         loop = asyncio.get_event_loop()
        
#         def delete_sync():
#             try:
#                 self.service.files().delete(fileId=file_id).execute()
#                 return True
#             except Exception as e:
#                 logger.error(f"Error deleting file {file_id}: {e}")
#                 return False
        
#         try:
#             result = await loop.run_in_executor(self.executor, delete_sync)
#             if result:
#                 logger.info(f"Successfully deleted file {file_id} from Google Drive")
#             return result
#         except Exception as e:
#             logger.error(f"Async delete error: {e}")
#             return False
    
#     def __del__(self):
#         """Cleanup thread pool executor"""
#         if hasattr(self, 'executor'):
#             self.executor.shutdown(wait=False)


import os
import logging
import asyncio
from pathlib import Path
from typing import Optional, Dict, Any

# --- Core Imports for the Final Solution ---
# We use `requests` for the actual upload and `googleapiclient` only for simple tasks like permissions.
import requests
from google.auth.transport.requests import AuthorizedSession
from google.oauth2.service_account import Credentials
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from concurrent.futures import ThreadPoolExecutor
import socket

logger = logging.getLogger(__name__)

class GoogleDriveUploader:
    """
    Robust, async Google Drive uploader that interacts directly with the Google Drive REST API
    for uploads, bypassing buggy library methods for maximum reliability.
    """

    def __init__(self, service_account_path: str, folder_id: Optional[str] = None, max_workers: int = 1):
        self.service_account_path = service_account_path
        self.folder_id = folder_id
        self.max_workers = max_workers
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
        self.upload_semaphore = asyncio.Semaphore(max_workers)
        
        # We still use the client library for simple, reliable tasks like verification.
        self._initialize_verification_service()

    def _initialize_verification_service(self):
        """Initializes a client to verify the folder ID."""
        try:
            if not os.path.exists(self.service_account_path):
                raise FileNotFoundError(f"Service account file not found: {self.service_account_path}")

            credentials = Credentials.from_service_account_file(
                self.service_account_path,
                scopes=['https://www.googleapis.com/auth/drive']
            )
            service = build('drive', 'v3', credentials=credentials, cache_discovery=False)
            logger.info("Google Drive service initialized successfully for verification.")
            self._verify_folder_id(service)

        except Exception as e:
            logger.error(f"Failed to initialize Google Drive service: {e}", exc_info=True)
            raise

    def _verify_folder_id(self, service):
        """Verify that the provided folder_id is valid and accessible."""
        if not self.folder_id:
            logger.info("No Google Drive folder ID provided. Files will be uploaded to the root directory.")
            return

        logger.info(f"Verifying access to Google Drive folder ID: {self.folder_id}")
        try:
            service.files().get(fileId=self.folder_id, fields='id').execute()
            logger.info("Successfully verified folder ID.")
        except HttpError as e:
            if e.resp.status == 404:
                logger.error(f"The specified Google Drive folder ID was not found: {self.folder_id}")
                raise FileNotFoundError(f"Google Drive folder with ID '{self.folder_id}' not found.")
            else:
                logger.error(f"An HTTP error occurred while verifying folder ID: {e}")
                raise

    async def upload_video_async(self, video_path: str, video_name: Optional[str] = None, retry_count: int = 3) -> Dict[str, Any]:
        """Upload video to Google Drive asynchronously with exponential backoff."""
        if not os.path.exists(video_path):
            raise FileNotFoundError(f"Video file not found: {video_path}")
        
        video_name = video_name or Path(video_path).name
        
        async with self.upload_semaphore:
            logger.info(f"Starting upload of {video_path} to Google Drive as {video_name}")
            
            for attempt in range(retry_count):
                result = await self._upload_with_retry(video_path, video_name, attempt)
                if result.get('success'):
                    return result
                
                if attempt < retry_count - 1:
                    wait_time = 2 ** (attempt + 1)
                    logger.warning(f"Upload attempt {attempt + 1} failed. Retrying in {wait_time}s...")
                    await asyncio.sleep(wait_time)
            
            return {
                'success': False,
                'error': f"Upload failed after {retry_count} attempts"
            }

    async def _upload_with_retry(self, video_path: str, video_name: str, attempt: int) -> Dict[str, Any]:
        """Handles a single upload attempt by calling the REST API directly."""
        loop = asyncio.get_event_loop()
        
        def upload_sync():
            """This synchronous function runs in a separate thread for safety."""
            try:
                credentials = Credentials.from_service_account_file(
                    self.service_account_path,
                    scopes=['https://www.googleapis.com/auth/drive']
                )
                
                # Use an authorized session from the modern `requests` library
                authed_session = AuthorizedSession(credentials)

                # === STEP 1: Initiate a Resumable Upload Session ===
                file_metadata = {
                    'name': video_name,
                    'description': f'Video uploaded via script (attempt {attempt + 1})'
                }
                if self.folder_id:
                    file_metadata['parents'] = [self.folder_id]

                init_headers = {"Content-Type": "application/json; charset=UTF-8"}
                init_url = "https://www.googleapis.com/upload/drive/v3/files?uploadType=resumable"
                
                init_response = authed_session.post(init_url, headers=init_headers, json=file_metadata)
                init_response.raise_for_status()  # Raises an exception for bad status codes (4xx or 5xx)
                
                # Get the unique upload URL from the 'Location' header
                upload_url = init_response.headers['Location']

                # === STEP 2: Upload the Actual File Content ===
                file_size = os.path.getsize(video_path)
                with open(video_path, 'rb') as f:
                    upload_response = authed_session.put(
                        upload_url,
                        headers={'Content-Length': str(file_size)},
                        data=f,
                        timeout=1800
                    )
                upload_response.raise_for_status()
                
                file_info = upload_response.json()
                file_id = file_info['id']

                # === STEP 3: Set Permissions (using the client library for this simple task) ===
                service = build('drive', 'v3', credentials=credentials, cache_discovery=False)
                service.permissions().create(
                    fileId=file_id,
                    body={'role': 'reader', 'type': 'anyone'}
                ).execute()

                # Construct final links
                web_view_link = f"https://drive.google.com/file/d/{file_id}/view"

                return {
                    'success': True, 'file_id': file_id, 'file_name': file_info['name'],
                    'web_view_link': web_view_link, 'size': file_size
                }
            
            except requests.exceptions.RequestException as e:
                logger.error(f"A network error occurred during upload: {e}")
                return {'success': False, 'error': f"Network Error: {str(e)}"}
            except HttpError as e:
                error_content = e.content.decode() if e.content else "No content"
                logger.error(f"A Google API HTTP error occurred during permissions setting: {error_content}")
                return {'success': False, 'error': f"Permissions HTTP error: {e.resp.status} - {error_content}"}
            except Exception as e:
                logger.error(f"An unexpected error occurred during upload: {e}", exc_info=True)
                return {'success': False, 'error': str(e)}

        return await loop.run_in_executor(self.executor, upload_sync)

    def __del__(self):
        if hasattr(self, 'executor'):
            self.executor.shutdown(wait=False)



# import os
# import logging
# import asyncio
# import time
# from pathlib import Path
# from typing import Optional, Dict, Any
# from google.oauth2.service_account import Credentials
# from googleapiclient.discovery import build
# from googleapiclient.http import MediaFileUpload
# from googleapiclient.errors import HttpError
# from concurrent.futures import ThreadPoolExecutor
# import ssl

# logger = logging.getLogger(__name__)

# class GoogleDriveUploader:
#     """Improved async Google Drive uploader for video files with better error handling"""

#     def __init__(self, service_account_path: str, folder_id: Optional[str] = None, max_workers: int = 1):
#         """
#         Initialize Google Drive uploader

#         Args:
#             service_account_path (str): Path to Google Service Account JSON file
#             folder_id (str, optional): Google Drive folder ID to upload to
#             max_workers (int): Maximum concurrent uploads (default: 1 for stability)
#         """
#         self.service_account_path = service_account_path
#         self.folder_id = folder_id
#         self.service = None
#         self.max_workers = max_workers
#         self.executor = ThreadPoolExecutor(max_workers=max_workers)
#         self.upload_semaphore = asyncio.Semaphore(max_workers)  # Limit concurrent uploads
        
#         # Initialize the service
#         self._initialize_service()

#     def _verify_folder_id(self):
#         """Verify that the provided folder_id is valid and accessible."""
#         if not self.folder_id:
#             logger.info("No Google Drive folder ID provided. Files will be uploaded to the root directory.")
#             return

#         logger.info(f"Verifying access to Google Drive folder ID: {self.folder_id}")
#         try:
#             # Request minimal fields to check for existence and permissions
#             self.service.files().get(fileId=self.folder_id, fields='id').execute()
#             logger.info("Successfully verified folder ID.")
#         except HttpError as e:
#             if e.resp.status == 404:
#                 logger.error(f"The specified Google Drive folder ID was not found: {self.folder_id}")
#                 raise FileNotFoundError(f"Google Drive folder with ID '{self.folder_id}' not found.")
#             elif e.resp.status == 403:
#                 logger.error(f"Permission denied for folder ID: {self.folder_id}. Ensure the service account has at least 'Editor' access.")
#                 raise PermissionError(f"Permission denied for Google Drive folder ID '{self.folder_id}'.")
#             else:
#                 logger.error(f"An HTTP error occurred while verifying folder ID: {e}")
#                 raise
#         except Exception as e:
#             logger.error(f"An unexpected error occurred during folder ID verification: {e}")
#             raise


#     def _initialize_service(self):
#         """Initialize Google Drive API service and verify folder ID."""
#         try:
#             if not os.path.exists(self.service_account_path):
#                 raise FileNotFoundError(f"Service account file not found: {self.service_account_path}")

#             scopes = ['https://www.googleapis.com/auth/drive']
#             credentials = Credentials.from_service_account_file(
#                 self.service_account_path,
#                 scopes=scopes
#             )

#             self.service = build('drive', 'v3', credentials=credentials)
#             logger.info("Google Drive service initialized successfully")
            
#             # ** NEW: Verify the folder ID after service is built **
#             self._verify_folder_id()

#         except Exception as e:
#             logger.error(f"Failed to initialize Google Drive service: {e}")
#             raise
    
#     async def upload_video_async(self, video_path: str, video_name: Optional[str] = None, retry_count: int = 3) -> Dict[str, Any]:
#         """
#         Upload video to Google Drive asynchronously with retry logic
        
#         Args:
#             video_path (str): Path to the video file
#             video_name (str, optional): Name for the uploaded file
#             retry_count (int): Number of retries on failure
            
#         Returns:
#             dict: Upload result with file_id, web_view_link, and download_link
#         """
#         if not os.path.exists(video_path):
#             raise FileNotFoundError(f"Video file not found: {video_path}")
        
#         if not video_name:
#             video_name = Path(video_path).name
        
#         async with self.upload_semaphore:
#             logger.info(f"Starting upload of {video_path} to Google Drive as {video_name}")
            
#             await asyncio.sleep(0.5)
            
#             for attempt in range(retry_count):
#                 try:
#                     result = await self._upload_with_retry(video_path, video_name, attempt)
#                     if result['success']:
#                         return result
                    
#                     # If not successful due to a non-exception error (like HttpError caught internally)
#                     if attempt < retry_count - 1:
#                         wait_time = (attempt + 1) * 2
#                         logger.warning(f"Upload attempt {attempt + 1} failed, retrying in {wait_time}s...")
#                         await asyncio.sleep(wait_time)
                
#                 except Exception as e:
#                     logger.error(f"Upload attempt {attempt + 1} raised an unhandled exception: {e}")
#                     if attempt < retry_count - 1:
#                         wait_time = (attempt + 1) * 2
#                         logger.warning(f"Retrying in {wait_time}s...")
#                         await asyncio.sleep(wait_time)
#                     else:
#                         return {
#                             'success': False,
#                             'error': f"All {retry_count} attempts failed. Last error: {str(e)}"
#                         }
            
#             return {
#                 'success': False,
#                 'error': f"Upload failed after {retry_count} attempts"
#             }

    
#     async def _upload_with_retry(self, video_path: str, video_name: str, attempt: int) -> Dict[str, Any]:
#         """Internal method to handle single upload attempt"""
        
#         file_metadata = {
#             'name': video_name,
#             'description': f'Optimized video generated by async video processor (attempt {attempt + 1})'
#         }
        
#         if self.folder_id:
#             file_metadata['parents'] = [self.folder_id]
        
#         loop = asyncio.get_event_loop()
        
#         def upload_sync():
#             try:
#                 # Using the already initialized service from self.service is generally fine,
#                 # but recreating credentials/service per thread can avoid statefulness issues.
#                 # Let's stick to your original design of recreating for thread safety.
#                 credentials = Credentials.from_service_account_file(
#                     self.service_account_path,
#                     scopes=['https://www.googleapis.com/auth/drive']
#                 )
      
#                 service = build('drive', 'v3', credentials=credentials)
                        

                
#                 media = MediaFileUpload(
#                     video_path,
#                     mimetype='video/mp4',
#                     resumable=True,
#                     chunksize=10 * 1024 * 1024  # 5MB chunks
#                 )
                
#                 request = service.files().create(
#                     body=file_metadata,
#                     media_body=media,
#                     fields='id,name,webViewLink,size,createdTime'
#                 )
                
#                 file = request.execute()
                
#                 service.permissions().create(
#                     fileId=file['id'],
#                     body={'role': 'reader', 'type': 'anyone'}
#                 ).execute()
                
#                 download_link = f"https://drive.google.com/uc?export=download&id={file['id']}"
                
#                 return {
#                     'success': True,
#                     'file_id': file['id'],
#                     'file_name': file['name'],
#                     'web_view_link': file['webViewLink'],
#                     'download_link': download_link,
#                     'size': file.get('size', 0),
#                     'created_time': file.get('createdTime'),
#                     'folder_id': self.folder_id,
#                     'attempt': attempt + 1
#                 }
                
#             except HttpError as e:
#                 error_content = e.content.decode() if e.content else "No content"
#                 logger.error(f"Google Drive HTTP error during upload: {e}")
#                 return {
#                     'success': False,
#                     'error': f"HTTP error: {e.resp.status} - {error_content}"
#                 }
#             except ssl.SSLError as e:
#                 logger.error(f"SSL error during upload: {e}")
#                 return { 'success': False, 'error': f"SSL error: {str(e)}" }
#             except Exception as e:
#                 logger.error(f"Error during Google Drive upload: {e}", exc_info=True)
#                 return { 'success': False, 'error': str(e) }
        
#         try:
#             result = await loop.run_in_executor(self.executor, upload_sync)
            
#             if result['success']:
#                 logger.info(f"Successfully uploaded {video_name} to Google Drive (attempt {attempt + 1})")
#                 logger.info(f"File ID: {result['file_id']}")
#                 logger.info(f"View Link: {result['web_view_link']}")
#             else:
#                 logger.error(f"Failed to upload {video_name} (attempt {attempt + 1}): {result['error']}")
            
#             return result
            
#         except Exception as e:
#             logger.error(f"Async upload error (attempt {attempt + 1}): {e}")
#             return { 'success': False, 'error': str(e) }
    
#     async def delete_file_async(self, file_id: str) -> bool:
#         """
#         Delete a file from Google Drive
        
#         Args:
#             file_id (str): Google Drive file ID
            
#         Returns:
#             bool: True if successful, False otherwise
#         """
#         loop = asyncio.get_event_loop()
        
#         def delete_sync():
#             try:
#                 self.service.files().delete(fileId=file_id).execute()
#                 return True
#             except Exception as e:
#                 logger.error(f"Error deleting file {file_id}: {e}")
#                 return False
        
#         try:
#             result = await loop.run_in_executor(self.executor, delete_sync)
#             if result:
#                 logger.info(f"Successfully deleted file {file_id} from Google Drive")
#             return result
#         except Exception as e:
#             logger.error(f"Async delete error: {e}")
#             return False
    
#     def __del__(self):
#         """Cleanup thread pool executor"""
#         if hasattr(self, 'executor'):
#             self.executor.shutdown(wait=False)
